[< к содержанию](./readme.md) |
[Основы Git: Получение репозитория Git >](./GettingGit.md)

 ## Что такое Git? 
___
Итак, что такое **Git** в двух словах? Это важный раздел для усвоения, потому что если вы понимаете, что такое **Git** и основы его работы, вам, вероятно, будет намного проще эффективно использовать Git. Изучая Git, постарайтесь очистить свой разум от вещей, которые вы, возможно, знаете о других системах контроля версий, таких как **CVS**, **Subversion** или **Perforce**, — это поможет вам избежать путаницы при использовании инструмента. Несмотря на то, что пользовательский интерфейс **Git** довольно похож на эти другие системы контроля версий, **Git** хранит информацию и обрабатывает ее совершенно по-другому, и понимание этих различий поможет вам не запутаться при ее использовании.

Снимки, а не различия
Основное различие между **Git** и любой другой системой контроля версий (включая Subversion и ее друзей) заключается в том, как **Git** думает о своих данных. Концептуально большинство других систем хранят информацию в виде списка изменений в файлах. Эти другие системы (**CVS, Subversion, Perforce, Bazaar** и т. д.) рассматривают информацию, которую они хранят, как набор файлов и изменений, вносимых в каждый файл с течением времени (это обычно описывается как дельта- контроль версий).
![](./assets/img1.png)
Рис. Хранение данных в виде изменений базовой версии каждого файла

**Git** не думает и не хранит свои данные таким образом. Вместо этого **Git** думает о своих данных как о серии снимков миниатюрной файловой системы. С **Git** каждый раз, когда вы фиксируете или сохраняете состояние своего проекта, **Git** в основном делает снимок того, как все ваши файлы выглядят в данный момент, и сохраняет ссылку на этот снимок. Чтобы быть эффективным, если файлы не изменились, **Git** не сохраняет файл снова, а только ссылку на предыдущий идентичный файл, который он уже сохранил. **Git** воспринимает свои данные как поток снимков 
![](./assets/img2.png)
Рис. Хранение данных в виде моментальных снимков проекта с течением времени

Это важное различие между **Git** и почти всеми другими системами контроля версий. Это заставляет **Git** пересмотреть почти все аспекты контроля версий, которые большинство других систем скопировали из предыдущего поколения. Это делает **Git** больше похожим на мини-файловую систему с несколькими невероятно мощными инструментами, созданными поверх нее, а не просто на систему контроля версий. Мы рассмотрим некоторые преимущества, которые вы получите, если будете думать о своих данных таким образом, когда будем рассматривать ветвление **Git** в [Git Branching](https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell#ch03-git-branching) .

### Почти каждая операция является локальной

Большинству операций в **Git** для работы нужны только локальные файлы и ресурсы — обычно не требуется никакой информации с другого компьютера в вашей сети. Если вы привыкли к **CVCS**, где большинство операций имеют накладные расходы на сетевую задержку, этот аспект **Git** заставит вас думать, что боги скорости благословили **Git** неземными силами. Поскольку у вас есть вся история проекта прямо на вашем локальном диске, большинство операций кажутся почти мгновенными.

Например, чтобы просмотреть историю проекта, **Git** не нужно обращаться к серверу, чтобы получить историю и отобразить ее для вас — он просто считывает ее непосредственно из вашей локальной базы данных. Это означает, что вы видите историю проекта почти мгновенно. Если вы хотите увидеть изменения, внесенные между текущей версией файла и файлом месячной давности, **Git** может найти файл месячной давности и выполнить локальный расчет разницы, вместо того, чтобы просить удаленный сервер сделать это или загрузите более старую версию файла с удаленного сервера, чтобы сделать это локально.

Это также означает, что вы мало что можете сделать, если вы не в сети или не подключены к **VPN**. Если вы садитесь в самолет или поезд и хотите немного поработать, вы можете с радостью выполнить коммит (в свою локальную копию, помните?), пока не доберетесь до сетевого подключения для загрузки. Если вы вернетесь домой и не сможете заставить свой **VPN**-клиент работать должным образом, вы все равно сможете работать. Во многих других системах это либо невозможно, либо болезненно. В **Perforce**, например, вы мало что можете сделать, если не подключены к серверу; в **Subversion** и **CVS** вы можете редактировать файлы, но не можете фиксировать изменения в своей базе данных (поскольку ваша база данных отключена). Это может показаться не таким уж большим делом, но вы можете быть удивлены, насколько большую разницу это может иметь.

### Git имеет целостность
Все в **Git** проверяется контрольной суммой перед сохранением, а затем упоминается по этой контрольной сумме. Это означает, что невозможно изменить содержимое любого файла или каталога без ведома **Git**. Эта функциональность встроена в **Git** на самых низких уровнях и является неотъемлемой частью его философии. Вы не можете потерять информацию при передаче или повредить файл, если **Git** не сможет это обнаружить.

Механизм, который Git использует для этой контрольной суммы, называется хэшем **SHA-1**. Это строка из 40 символов, состоящая из шестнадцатеричных символов **(0–9 и a–f)** и вычисляемая на основе содержимого файла или структуры каталогов в **Git**. Хэш **SHA-1** выглядит примерно так:

`24b9da6552252987aa493b52f8696cd6d3b00373`

Вы будете видеть эти хэш-значения 
повсюду в **Git**, потому что он так часто их использует. На самом деле **Git** хранит все в своей базе данных не по имени файла, а по хеш-значению его содержимого.

### Git обычно только добавляет данные

Когда вы выполняете действия в **Git**, почти все они только добавляют данные в базу данных **Git**. Трудно заставить систему делать что-либо, что нельзя отменить, или заставить ее каким-либо образом стирать данные. Как и в случае с любой системой контроля версий, вы можете потерять или испортить изменения, которые вы еще не зафиксировали, но после того, как вы зафиксируете моментальный снимок в **Git**, его очень сложно потерять, особенно если вы регулярно перемещаете свою базу данных в другой репозиторий.

Это делает использование **Git** удовольствием, потому что мы знаем, что можем экспериментировать, не рискуя сильно напортачить. Более подробно о том, как Git хранит свои данные и как можно восстановить данные, которые кажутся потерянными, см . в разделе [Undoing Things](https://git-scm.com/book/en/v2/Git-Basics-Undoing-Things#_undoing) .

### Три состояния
Теперь обратите внимание — вот главное, что нужно помнить о **Git**, если вы хотите, чтобы остальная часть вашего процесса обучения прошла гладко. У **Git** есть три основных состояния, в которых могут находиться ваши файлы: *модифицировано , поставлено и зафиксировано* :

* Измененный означает, что вы изменили файл, но еще не зафиксировали его в своей базе данных.

* Поэтапное означает, что вы пометили измененный файл в его текущей версии для перехода к следующему снимку коммита.

* Подтверждение означает, что данные безопасно хранятся в вашей локальной базе данных.

Это приводит нас к трем основным разделам проекта **Git**: рабочему дереву, промежуточной области и каталогу **Git**.
![](./assets/img3.png)
Рис. Рабочее дерево, промежуточная область и каталог **Git**

***Рабочее дерево*** — это единая проверка одной версии проекта. Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск для использования или изменения.

***Промежуточная область*** — это файл, обычно содержащийся в вашем каталоге Git, в котором хранится информация о том, что войдет в ваш следующий коммит. Его техническое название на языке Git — «индекс», но фраза «промежуточная область» работает так же хорошо.

***Каталог _Git_*** — это место, где Git хранит метаданные и базу данных объектов для вашего проекта. Это самая важная часть Git, и именно она копируется при клонировании репозитория с другого компьютера.

### Базовый рабочий процесс Git выглядит примерно так:

1. Вы изменяете файлы в своем рабочем дереве.

2. Вы выборочно размещаете только те изменения, которые хотите включить в следующую фиксацию, добавляя только эти изменения в область подготовки.

3. Вы делаете фиксацию, которая берет файлы в том виде, в котором они находятся в промежуточной области, и постоянно сохраняет этот моментальный снимок в вашем каталоге Git.

Если определенная версия файла находится в каталоге **Git**, она считается **_зафиксированной_** . Если он был изменен и добавлен в промежуточную область, он является **_промежуточным_** . И если он был изменен с момента извлечения, но не был подготовлен, он **_изменен_** . В [Git Basics](https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository#ch02-git-basics-chapter) вы узнаете больше об этих состояниях и о том, как вы можете либо воспользоваться ими, либо полностью пропустить поэтапную часть.